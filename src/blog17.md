# 矩阵乘法

Data: 2024/01/22\

## Note
矩阵乘法的时间复杂度为O(n^3). 当电脑内存有限的情况下, 减少复制进内存的次数可以加速矩阵乘法.


## 传统矩阵乘法

4x4的矩阵AB相乘, 得到的结果矩阵为R.
```
R = A * B
```
在计算R的第一行, 电脑需要把A的第一行读入内存, 然后读取B的每一列.
假设把一个数字复制进内存耗时 O(1), 因为R有n行, B中的每一列有n个数字,
所以计算整个R O(n^3)的时间复杂度.

观察下图中T0, T1, T2, T3 -- 左上角四分之一的矩阵,用传统乘法计算需要复制多少个数字进入内存呢?
对于每一个Ti需要一行A,一列B,所以一共需要复制32个数字进入内存.

```
4    *    4    *   4 = 32
t0-t3    a1-a4    b1-b4
图中的下角标有点乱了XD
```

![图片](https://raw.githubusercontent.com/AllenAnZifeng/blog_content/master/resources/blog17/mat._cut.jpg)


## Tiled 矩阵乘法 -- 像瓷砖一样一块一块乘

观察上图我们把矩阵分成了4块2x2的tile. 现在重新计算T0 - T3, 先把2个tile分别放在A, B的左上角,
然后将A, B的tile做传统矩阵乘法,写入R. 然后将A的tile向右移动, B的tile向下移动, 再进行一次传统矩阵乘法写入R.
对于T0来说, 图中打勾的元素都已经相乘并且加入到T0. 

用这种方法需要复制多少个数字进入内存呢?

我们用了A,B中的2个tile,分别移动了一次, 所以一共复制了16个数字进入内存, 比传统方法少了一半 32/16 = 2.

```
(4   +    4)    *   2 = 16
tile A    tile B    2步
```

注意: 加法乘法的运算次数没有变化, 复制数字进入内存的数量减半.

假设tile的大小为b x b, 矩阵n x n, 计算复制数字进入内存的复杂度
```
对于R中每一个tile来说, A,B 中的tile要复制多少数字?
2 * b^2 * (n/b) 
n/b 是tile移动的步数, b^2是每个tile的面积, 2是A,B两个tile

那么R中一共有多少个tile需要计算呢?
(n/b)^2

所以复杂度如下:
2 * b^2 * (n/b) * (n/b)^2 = 2 * n^3 / b = O(n^3 / b) 

```



## 总结

Memory Copy Complexity
传统矩阵乘法: O(n^3)
Tiled 矩阵乘法: O(n^3 / b)

怎么理解除以b?
计算R中T0, T2时, B中的b1, b3被同时复制进入内存, 相当于B的column中的一个长度为b的segment被复制进内存后完成了R中2个row的计算, 
这样对column的复制从n减少到n/b